package com.example.study_kotlin2.ChapterMemo;

/*
Chapter 8
UI 프래그먼트와 프래그먼트 매니저

UI 유연성의 필요
가정 : List와 Detail로 이루어진 앱 - List를 클릭하면 상세 정보를 띄어주는 앱
- 이 앱을 List와 Detail 페이지를 동시에 보여줄 수 있을 만큼의 큰 크기를 지닌 장치에서 실행시키거나
사용자가 범죄의 상세 내역을 보면서 리스트의 다음 범죄를 보기 원한다고 했을 때 동시에 보여주는 방법이 필요하다.
       (원래대로 라면)                   (원하는 화면)
리스트 화면 클릭 시 -> 디테일 화면          리스트 + 디테일
- UI 유연성이란, 사용자나 장치가 요구하는 것에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력이다.
- 액티비티는 이런 유연성을 제공하도록 설계되지 않았다. 액티비티의 뷰들은 런타임 시에 변경되며, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다.

프래그먼트(Fragment)
- 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체이다.
- UI를 관리하는 프래그먼트를 UI 프래그먼트라고 한다.
- UI 프래그먼트는 레이아웃 파일로부터 인플레이트되는 자신의 뷰를 하나 가진다.
- 프래그먼트 뷰는 사용자가 상호작용하기 원하는 UI 요소들을 포함한다.
- 액티비티 뷰는 자신이 UI를 가지는 대신 프래그먼트를 넣을 컨테이너를 가지고 여러개의 프래그먼트를 통해 사용자와 다양한 상호작용이 가능하다.
- 프래그먼트가 교체되도 액티비티는 소멸하지 않는다.

이 절에서 프래그먼트의 특성
1. 프래그먼트의 onCreate 는 public 함수이다.
코틀린에서 함수를 정의할 때 가시성 한정자(visibility modifier)를 지정하지 않으면 기본적으로 public이 되기 떄문이다.
Fragment의 다른 생명주기 함수들도 public 이어야 한다. 이 함수들도 프래그먼트를 호스팅하는 어떤 액티비티에서도 자동 호출될 것이기 때문이다.
2. 프래그먼트는 액티비티와 유사하게 자신의 상태 데이터를 저장하거나 가져오는 Bundle 객체를 가진다.
필요에 따라 Fragment.onSaveInstanceState(Bundle) 함수를 오버라이드 할 수 있다.
3. Fragment onCreate에서는 프래그먼트 뷰를 인플레이트하지 않는다.
프래그먼트의 인스턴스는 구성하지만, 프래그먼트의 뷰는 또 다른 생명주기 함수인 onCreateVIew(LayoutInflater, ViewGroup?, Bundle?)에서 생성하고 구성한다.

FragmentManager
- FragmentManager 는 프래그먼트 트랜잭션의 백 스택을 유지 관리한다.
- FragmentManager.beginTransaction() 함수는 FragmentTransaction의 인스턴스를 생성해 반환한다.
- FragmentTransaction 클래스는 플루언트 인터페이스(fluent interface)를 사용한다.

Fragment의 생명주기(블로그 참고)

Fragment를 사용하는 앱의 아키텍쳐
- 프래그먼트는 주요 컴포넌트를 재사용하게끔 캡슐화한다.
- 주요 컴포넌트는 앱의 전체 화면에 나타난다.
- 만일 한번에 너무 많은 프래그먼트를 화면에 넣는다면, 프래그먼트 트랜잭션때문에 코드가 지저분하게 된다.
- 따라서 작은 컴포넌트들을 재사용할 때는 프래그먼트 대신 커스텀 뷰(view의 서브 클래스 또는 view의 서브 클래스의 서브 클래스)로 추출하는 것이 좋은 방법이다.
- 일반적으로 한 화면에 최대 2~3개의 프래그먼트를 사용하는 것이 좋다.
 */
