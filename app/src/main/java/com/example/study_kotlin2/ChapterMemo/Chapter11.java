package com.example.study_kotlin2.ChapterMemo;

/*
Chapter 11
데이터베이스와 Room 라이브러리

Room 아키텍처 컴포넌트 라이브러리
- Room은 Jetpack의 아키텍쳐 컴포넌트 라이브러리로, 데이터베이스 설정과 사용을 쉽게 해준다.
- Room을 사용하면 어노테이션이 지정된 코틀린 클래스로 데이터베이스 구조와 쿼리를 정의할 수 있다.
- Room은 API, Annotation, Compiler로 구성되어 있다.

SQLite
- Room은 내부적으로 SQLite를 사용한다.
- SQLite는 MySQLd이나 PostgreSQL같은 오픈 소스 관계형 데이터베이스이다.
- 다른 데이터베이스와 달리 SQLite는 라이브러리를 사용해서 데이터를 읽거나 데이터를 쓸 수 있는 파일에 저장한다.

데이터 베이스 생성하기
- 모델 클래스에 어노테이션을 지정해 데이터베이스 엔터티(Entity)를 만든다.
- 데이터베이스 자체를 나타내는 클래스를 생성한다.
- 데이터베이스가 모델 데이터를 처리할 수 있게 타입 변환기를 생성한다.

1. 엔터티(Entity) 정의하기
- Room은 우리가 정의한 엔터티를 기반으로 앱의 데이터베이스 테이블 구조를 만든다.
- 엔터티는 우리가 생성하는 모델 클래스로 @Entity 어노테이션으로 지정한다.
- @PrimaryKey 어노테이션으로 객체에 고유한 값을 지정해준다. 이 값으로 쿼리를 실행할 수 있다.

2. 데이터베이스 클래스 생성하기
- 엔터티 클래스는 데이터베이스 테이블의 구조를 정의한다.
- 앱에 여러 개의 데이터베이스가 있을 떄는 특정 엔터티 클래스는 여러 데이터베이스에서 사용될 수 있다.
- 엔터티 클래스를 데이터베이스와 연관시켜주어야 Room이 테이블을 생성하는데 사용할 수 있다.
- @Database 어노테이션은 이 클래스가 앱의 데이터베이스를 나타낸다고 Room에게 알려준다.
- 데이터베이스를 처음 생성했을 때는 버전이 1이다. 그리고 계속 개발하는 동안 새로운 엔터티를 추가하거나 기존 엔터티에 새로운 속성을 추가할 수 있는데,
추가할 때는 @Database 어노테이션의 엔터티들을 변경하거나 데이터베이스 버전 번호를 증가시켜야한다.

3. 타입 변환기 생성하기
- Roomd은 기본 데이터 타입을 SQLite 데이터베이스 테이블에 쉽게 저장할 수 있지만, 이외의 다른 타입은 문제가 생길 수 있다.
- Crime 클래스에는 Room이 저장 방법을 모르는 Date와 UUID 타입 속성이 있다. 이런 타입의 데이터를 데이터베이스 테이블에 저장하거나 가져오는 방법을 Room에게 알려주어야 한다.
- 데이터 타입을 변환하는 방법을 Room에게 알려주려면 타입 변환기를 지정하면 된다. 타입 변환기는 Room에게 특정 타입을 데이터베이스에 저장되는 타입으로 변환하는 방법을 알려준다.
- 각 타입에 대해서 @TypeConverter 어노테이션을 사용한다.

4. DAO 정의하기
- 데이터베이스 테이블의 데이터를 액세스하려면 DAO(Data Access Object)를 생성해야 한다.
- DAO는 데이터베이스 작업을 수행하는 함수들을 포함하는 인터페이스이다.
- @Query 어노테이션을 통해 데이터베이스의 데이터를 읽는다.

5. 리포지터리 패턴으로 데이터베이스 액세스
- 데이터베이스 액세스를 위해 리포지터리 패턴을 사용한다. (https://developer.android.com/docs/guide)
- 리포지터리 클래스는 리포지터리(데이터 저장소)를 구현한다.
- 또한 단일 또는 여러 소스로부터 데이터를 액세스하는 로직을 캡슐화하고, 로컬 데이터베이스나 원격 서버로부터 특정 데이터 셋을 가져오거나 저장하는 방법을 결정한다.
- 여기서 CrimeRepository는 싱글톤이다. 앱이 실행되는 동안 하나의 인스턴스만 생성된다.

테스트 데이터베이스 업로드하기
- 안드로이드 장치의 각 애플리케이션은 자신의 샌드박스에 디렉터리를 갖는다. 그리고 샌드박스에 파일을 저장하면 다른 앱이나, 다른 사용자가 액세스 하는 것을 막아준다.(루팅되지 않았을 경우)
- 각 앱의 샌드박스 디렉터리는 /data/data 뒤에 앱 패키지 이름이 붙는 디렉터리가 된다.
- 안로이드 오른쪽 아래 Device File Explorer -> data/data/패키지명 오른쪽 마우스 클릭 -> upload

애플리케이션의 스레드
- Room은 메인 스레드에서의 데이터베이스 액세스를 허용하지 않으며, 액세스를 시도하면 에러가 발생한다.
- 스레드는 단일의 실행 시퀀스다. 스레드 내부의 코드는 한 단계씩 실행된다.
- 모든 안드로이드 앱은 main 스레드로 시작된다. 그러나 main 스레드는 미리 정해진 순서로 실행되지 않는다.
- 대신 무한 루프에 머물면서 사용자나 시스템이 유발한 이벤트를 기다린다. 그리고 이벤트가 발생하면 응답하는 코드를 실행한다.
- main 스레드는 UI를 변경하는 모든 코드를 실행하며, 액티비티 시작, 버튼 누름 등 서로 다른 UI 관련 이벤트들에 대한 응답으로 실행되는 코드들도 포함된다.
- 이벤트들은 어떤 형태로든 모두 UI와 관련이 있어서 main 스레드를 UI 스레드라고도 한다.

백그라운드 스레드
- 데이터베이스 액세스는 다른 일보다 시간이 많이 걸린다. 이 시간동안 UI는 완전히 응답 불가능이 될 것이고, 결국 ANR을 초래하게 된다.
- main 스레드가 중요한 이벤트에 대한 응답에 실패했다고 안드로이드 와치독(watchdog)이 판단하면 ANR이 발생하며 앱이 중단된다.
- 장기간 실행되는 모든 작업은 백그라운드 스레드로 수행되어야 한다.
- UI는 main 스레드에서만 변경할 수 있다.

LiveData
- LiveData는 Jetpack의 lifecycler-extensions 라이브러리에 있는 홀더 클래스이며, Room에서 LiveData를 사용한다.
- Livedata의 목적은 앱의 서로 다른 부분 간에 데이터 전달을 쉽게 만드는 것이다.
- Livedata는 스레드 간에도 데이터를 전달할 수 있어서 백그라운드 스레드에서 main스레드로 데이터를 전달할 수 있다.
- Room DAO 쿼리에서 LiveData를 반환하도록 구성하면, Room이 백그라운드 스레드에서 쿼리 작업을 자동 실행한 후 그 결과를 LiveData 객체로 반환한다.
따라서 액티비티나 프래그먼트에서는 LiveData 갹체를 관찰하도록 설정만 하면 된다.




 */

//Implementation
//- implementation 'androidx.room:room-runtime:2.2.6'
//- kapt 'androidx.room:room-compiler:2.2.6'
